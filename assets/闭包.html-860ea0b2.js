const e=JSON.parse(`{"key":"v-41ae00f4","path":"/knowledge/%E9%97%AD%E5%8C%85.html","title":"闭包","lang":"zh-CN","frontmatter":{"description":"闭包是一个函数。 闭包可以让内层函数记住并访问外层函数的作用域，即使外层函数已经销毁。 闭包的一个使用场景是：封装私有变量。 在原生JS中没有私有变量的概念，可以使用闭包实现类似的效果。例如在函数内部定义变量，并返回一组内部函数，用于访问和操作内部变量，而函数外部不可直接访问这些内部变量。 另一个使用场景是：延长变量的生命周期，例如[[函数柯里化]]","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/knowledge/%E9%97%AD%E5%8C%85.html"}],["meta",{"property":"og:site_name","content":"Guo's Page"}],["meta",{"property":"og:title","content":"闭包"}],["meta",{"property":"og:description","content":"闭包是一个函数。 闭包可以让内层函数记住并访问外层函数的作用域，即使外层函数已经销毁。 闭包的一个使用场景是：封装私有变量。 在原生JS中没有私有变量的概念，可以使用闭包实现类似的效果。例如在函数内部定义变量，并返回一组内部函数，用于访问和操作内部变量，而函数外部不可直接访问这些内部变量。 另一个使用场景是：延长变量的生命周期，例如[[函数柯里化]]"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-10-31T02:14:39.000Z"}],["meta",{"property":"article:modified_time","content":"2023-10-31T02:14:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"闭包\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-10-31T02:14:39.000Z\\",\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":1698718479000,"updatedTime":1698718479000,"contributors":[{"name":"GuoXiCheng","email":"34238809+GuoXiCheng@users.noreply.github.com","commits":1}]},"readingTime":{"minutes":0.52,"words":156},"filePathRelative":"knowledge/闭包.md","localizedDate":"2023年10月31日","autoDesc":true}`);export{e as data};
